<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Noctua — Topic Coverage 3D</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a0f;
    color: #c8c8d0;
    font-family: 'Space Mono', monospace;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
  }

  #canvas-container {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
  }

  /* Header */
  #header {
    position: absolute;
    top: 20px; left: 24px;
    z-index: 10;
    pointer-events: none;
  }
  #header h1 {
    font-size: 14px;
    font-weight: 700;
    color: #7DF9AA;
    letter-spacing: 2px;
    text-transform: uppercase;
  }
  #header p {
    font-size: 10px;
    color: #555;
    margin-top: 4px;
    letter-spacing: 1px;
  }

  /* View toggle */
  #view-toggle {
    position: absolute;
    top: 20px; right: 24px;
    z-index: 10;
    display: flex;
    gap: 0;
  }
  .toggle-btn {
    background: transparent;
    border: 1px solid #333;
    color: #666;
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    padding: 6px 14px;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 1px;
  }
  .toggle-btn:first-child { border-radius: 3px 0 0 3px; }
  .toggle-btn:last-child { border-radius: 0 3px 3px 0; }
  .toggle-btn.active {
    background: #7DF9AA15;
    border-color: #7DF9AA;
    color: #7DF9AA;
  }
  .toggle-btn:hover:not(.active) {
    border-color: #555;
    color: #999;
  }

  /* Sidebar topic toggles */
  #sidebar {
    position: absolute;
    top: 80px; right: 24px;
    z-index: 10;
    width: 180px;
  }
  .topic-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 0;
    cursor: pointer;
    user-select: none;
    transition: opacity 0.2s;
  }
  .topic-toggle:hover { opacity: 1 !important; }
  .topic-toggle .dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    transition: opacity 0.2s;
  }
  .topic-toggle.off .dot { opacity: 0.2; }
  .topic-toggle .label {
    font-size: 10px;
    color: #777;
    letter-spacing: 0.5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .topic-toggle.off .label { color: #444; text-decoration: line-through; }
  .topic-toggle .pct {
    margin-left: auto;
    font-size: 9px;
    color: #555;
    font-variant-numeric: tabular-nums;
  }

  /* Timeline scrubber */
  #timeline {
    position: absolute;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 12px;
    background: #12121a;
    border: 1px solid #222;
    border-radius: 4px;
    padding: 8px 16px;
  }
  #timeline label {
    font-size: 10px;
    color: #555;
    letter-spacing: 1px;
    text-transform: uppercase;
    white-space: nowrap;
  }
  #timeline input[type="range"] {
    width: 300px;
    accent-color: #7DF9AA;
    cursor: pointer;
  }
  #episode-label {
    font-size: 11px;
    color: #7DF9AA;
    min-width: 60px;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }
  #play-btn {
    background: none;
    border: 1px solid #333;
    color: #7DF9AA;
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    padding: 3px 10px;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s;
  }
  #play-btn:hover { border-color: #7DF9AA; }

  /* Tooltip */
  #tooltip {
    position: absolute;
    z-index: 20;
    pointer-events: none;
    background: #16161e;
    border: 1px solid #7DF9AA44;
    border-radius: 4px;
    padding: 8px 12px;
    font-size: 10px;
    line-height: 1.6;
    color: #c8c8d0;
    display: none;
    max-width: 200px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  }
  #tooltip .tt-topic { color: #7DF9AA; font-weight: 700; }
  #tooltip .tt-dim { color: #666; }
</style>
</head>
<body>

<div id="canvas-container"></div>

<div id="header">
  <h1>Topic Coverage</h1>
  <p>3D radar · 30 episodes</p>
</div>

<div id="view-toggle">
  <button class="toggle-btn active" onclick="setView('cumulative')">Cumulative</button>
  <button class="toggle-btn" onclick="setView('latest')">Latest</button>
</div>

<div id="sidebar"></div>

<div id="timeline">
  <button id="play-btn" onclick="togglePlay()">&#9654;</button>
  <label>Episode</label>
  <input type="range" id="scrubber" min="0" max="29" value="29" oninput="onScrub(this.value)">
  <span id="episode-label">Ep 30</span>
</div>

<div id="tooltip"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
// ── DATA ──────────────────────────────────────────────────────────────────────

// Defaults — overwritten by API data when available
let TOPICS = [
  { name: "Latest in Tech",   alloc: 5 },
  { name: "Product Mgmt",     alloc: 4 },
  { name: "World Politics",   alloc: 4 },
  { name: "US Politics",      alloc: 3 },
  { name: "Indian Politics",  alloc: 3 },
  { name: "Entertainment",    alloc: 3 },
  { name: "CrossFit",         alloc: 2 },
  { name: "Formula 1",        alloc: 2 },
  { name: "Arsenal",          alloc: 1 },
  { name: "Indian Cricket",   alloc: 1 },
  { name: "Badminton",        alloc: 1 },
  { name: "Sports",           alloc: 1 },
  { name: "Seattle",          alloc: 1 },
  { name: "Misc",             alloc: 1 },
];

let NUM_TOPICS = TOPICS.length;
let NUM_EPISODES = 30;

// Topic colors — distinct hues around the wheel
const TOPIC_COLORS = [
  0x7DF9AA, 0x5BC4F7, 0xF7A35B, 0xF75B7D, 0xD95BF7,
  0xF7E85B, 0x5BF7D9, 0xF75B5B, 0x5B7DF7, 0xA3F75B,
  0xF7C45B, 0x5BF7A3, 0xC45BF7, 0x8899AA,
];

// Generate realistic mock data (fallback when API unavailable)
function generateMockData() {
  const episodes = [];
  const baselines = [0.7, 0.3, 0.8, 0.65, 0.5, 0.75, 0.6, 0.55, 0.4, 0.35, 0.25, 0.6, 0.45, 0.7];
  const trends = [0.005, -0.008, 0.003, 0.002, 0.01, -0.003, 0.008, 0.004, -0.005, 0.012, -0.006, 0.001, 0.003, -0.002];
  const peakEp = [null, null, null, null, 20, null, 15, 18, null, 22, null, null, 12, null];

  for (let ep = 0; ep < 30; ep++) {
    const coverage = [];
    for (let t = 0; t < TOPICS.length; t++) {
      let base = (baselines[t] || 0.5) + (trends[t] || 0) * ep;
      if (peakEp[t] !== null) {
        const dist = ep - peakEp[t];
        base += 0.3 * Math.exp(-dist * dist / 18);
      }
      const noise = (Math.random() - 0.5) * 0.25;
      let val = base + noise;
      if (ep % 7 >= 5 && t < 6) val *= 0.7;
      val = Math.max(0, Math.min(1.3, val));
      if (Math.random() < 0.08) val = 0;
      coverage.push(Math.round(val * 100) / 100);
    }
    episodes.push({
      episode: ep + 1,
      date: `2026-02-${String(ep + 1).padStart(2, '0')}`,
      coverage,
    });
  }
  return episodes;
}

let EPISODES = generateMockData();

// Fetch real data from API
async function loadRealData() {
  try {
    const res = await fetch('/api/topic-coverage-3d');
    if (!res.ok) return false;
    const data = await res.json();
    if (!data.episodes || data.episodes.length < 2) return false;

    TOPICS = data.topics;
    NUM_TOPICS = TOPICS.length;
    EPISODES = data.episodes.map((ep, i) => ({
      episode: i + 1,
      date: ep.date,
      coverage: ep.coverage,
    }));
    NUM_EPISODES = EPISODES.length;
    topicVisible = new Array(NUM_TOPICS).fill(true);

    // Update UI
    document.getElementById('scrubber').max = NUM_EPISODES - 1;
    document.getElementById('scrubber').value = NUM_EPISODES - 1;
    scrubberValue = NUM_EPISODES - 1;
    document.getElementById('episode-label').textContent = `Ep ${NUM_EPISODES}`;
    document.querySelector('#header p').textContent = `3D radar · ${NUM_EPISODES} episodes`;

    return true;
  } catch (e) {
    console.warn('API unavailable, using mock data:', e);
    return false;
  }
}

// ── STATE ─────────────────────────────────────────────────────────────────────

let viewMode = 'cumulative'; // 'cumulative' | 'latest'
let scrubberValue = NUM_EPISODES - 1;
let topicVisible = new Array(NUM_TOPICS).fill(true);
let isPlaying = false;
let playInterval = null;

// ── THREE.JS SETUP ────────────────────────────────────────────────────────────

const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0f);
scene.fog = new THREE.FogExp2(0x0a0a0f, 0.015);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
camera.position.set(12, 10, 20);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.target.set(0, 0, -8);
controls.minDistance = 5;
controls.maxDistance = 60;
controls.update();

// Lighting
const ambient = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight.position.set(10, 20, 15);
scene.add(dirLight);

// ── GEOMETRY BUILDERS ─────────────────────────────────────────────────────────

const Z_SPACING = 0.9;
const RADIUS_SCALE = 6;

// Radar axis helpers
function topicAngle(i) {
  return (i / NUM_TOPICS) * Math.PI * 2 - Math.PI / 2;
}

function radarPoint(topicIdx, value, z) {
  const angle = topicAngle(topicIdx);
  const r = value * RADIUS_SCALE;
  return new THREE.Vector3(
    Math.cos(angle) * r,
    Math.sin(angle) * r,
    z
  );
}

// Groups for managing visibility
const sliceGroup = new THREE.Group();
const ribbonGroup = new THREE.Group();
const axisGroup = new THREE.Group();
scene.add(sliceGroup);
scene.add(ribbonGroup);
scene.add(axisGroup);

// ── AXIS LINES & LABELS ──────────────────────────────────────────────────────

function buildAxes() {
  while (axisGroup.children.length) axisGroup.remove(axisGroup.children[0]);

  const axisMat = new THREE.LineBasicMaterial({ color: 0x222233, transparent: true, opacity: 0.5 });

  for (let t = 0; t < NUM_TOPICS; t++) {
    const angle = topicAngle(t);
    const geo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(Math.cos(angle) * RADIUS_SCALE * 1.4, Math.sin(angle) * RADIUS_SCALE * 1.4, 0),
    ]);
    const line = new THREE.Line(geo, axisMat);
    axisGroup.add(line);
  }

  // Concentric guide rings at 50% and 100%
  [0.5, 1.0].forEach(pct => {
    const pts = [];
    for (let i = 0; i <= NUM_TOPICS; i++) {
      const angle = topicAngle(i % NUM_TOPICS);
      const r = pct * RADIUS_SCALE;
      pts.push(new THREE.Vector3(Math.cos(angle) * r, Math.sin(angle) * r, 0));
    }
    const ringGeo = new THREE.BufferGeometry().setFromPoints(pts);
    const ringMat = new THREE.LineBasicMaterial({
      color: pct === 1.0 ? 0x333344 : 0x1a1a2a,
      transparent: true,
      opacity: pct === 1.0 ? 0.6 : 0.3,
    });
    axisGroup.add(new THREE.Line(ringGeo, ringMat));
  });
}

buildAxes();

// ── BUILD RADAR SLICES ────────────────────────────────────────────────────────

const sliceMeshes = [];    // One per episode
const ribbonMeshes = [];   // One per topic (ribbon connecting slices)

function buildSlice(epIdx) {
  const ep = EPISODES[epIdx];
  const z = -epIdx * Z_SPACING;
  const timeFrac = epIdx / (NUM_EPISODES - 1); // 0=oldest, 1=newest

  // Polygon vertices: center + ring
  const vertices = [];
  const indices = [];
  const colors = [];

  // Center vertex
  vertices.push(0, 0, z);
  const baseColor = new THREE.Color(0x7DF9AA);
  const dimColor = new THREE.Color(0x1a3a2a);
  const c = dimColor.clone().lerp(baseColor, 0.3 + timeFrac * 0.7);
  colors.push(c.r, c.g, c.b);

  // Ring vertices
  for (let t = 0; t < NUM_TOPICS; t++) {
    const val = topicVisible[t] ? ep.coverage[t] : 0;
    const pt = radarPoint(t, val, z);
    vertices.push(pt.x, pt.y, pt.z);

    const tc = new THREE.Color(TOPIC_COLORS[t]);
    const blended = dimColor.clone().lerp(tc, 0.2 + timeFrac * 0.6);
    colors.push(blended.r, blended.g, blended.b);
  }

  // Triangles: center to each pair of adjacent ring vertices
  for (let t = 0; t < NUM_TOPICS; t++) {
    const next = (t + 1) % NUM_TOPICS;
    indices.push(0, t + 1, next + 1);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geo.setIndex(indices);
  geo.computeVertexNormals();

  const mat = new THREE.MeshBasicMaterial({
    vertexColors: true,
    transparent: true,
    opacity: 0.15 + timeFrac * 0.35,
    side: THREE.DoubleSide,
    depthWrite: false,
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.userData = { episodeIdx: epIdx };
  return mesh;
}

function buildSliceOutline(epIdx) {
  const ep = EPISODES[epIdx];
  const z = -epIdx * Z_SPACING;
  const timeFrac = epIdx / (NUM_EPISODES - 1);

  const pts = [];
  for (let t = 0; t <= NUM_TOPICS; t++) {
    const ti = t % NUM_TOPICS;
    const val = topicVisible[ti] ? ep.coverage[ti] : 0;
    pts.push(radarPoint(ti, val, z));
  }

  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const color = new THREE.Color(0x7DF9AA);
  const dim = new THREE.Color(0x1a3a2a);
  const c = dim.clone().lerp(color, 0.3 + timeFrac * 0.7);

  const mat = new THREE.LineBasicMaterial({
    color: c,
    transparent: true,
    opacity: 0.2 + timeFrac * 0.6,
  });

  return new THREE.Line(geo, mat);
}

// ── BUILD RIBBONS ─────────────────────────────────────────────────────────────

function buildRibbon(topicIdx) {
  if (!topicVisible[topicIdx]) return null;

  const maxEp = scrubberValue + 1;
  if (maxEp < 2) return null;

  const vertices = [];
  const colors = [];
  const indices = [];

  const tc = new THREE.Color(TOPIC_COLORS[topicIdx]);
  const dimTc = new THREE.Color(0x0a0a0f);

  for (let ep = 0; ep < maxEp; ep++) {
    const z = -ep * Z_SPACING;
    const val = EPISODES[ep].coverage[topicIdx];
    const pt = radarPoint(topicIdx, val, z);
    const timeFrac = ep / (NUM_EPISODES - 1);

    // Two vertices per episode: one at center, one at radar point
    vertices.push(0, 0, z);
    vertices.push(pt.x, pt.y, pt.z);

    const alpha = 0.15 + timeFrac * 0.85;
    const c = dimTc.clone().lerp(tc, alpha);
    colors.push(c.r, c.g, c.b);
    colors.push(c.r, c.g, c.b);
  }

  // Build quad strip
  for (let ep = 0; ep < maxEp - 1; ep++) {
    const i = ep * 2;
    // Only connect outer edges (indices 1 and 3 of each pair)
    indices.push(i + 1, i + 3, i + 2 + 1);
    // Actually, build quads between adjacent episode outer points
  }

  // Simpler approach: ribbon as line strip along the outer edge
  const pts = [];
  for (let ep = 0; ep < maxEp; ep++) {
    const z = -ep * Z_SPACING;
    const val = EPISODES[ep].coverage[topicIdx];
    pts.push(radarPoint(topicIdx, val, z));
  }

  const geo = new THREE.BufferGeometry().setFromPoints(pts);

  // Vertex colors for depth
  const lineColors = [];
  for (let ep = 0; ep < maxEp; ep++) {
    const timeFrac = ep / (NUM_EPISODES - 1);
    const c = dimTc.clone().lerp(tc, 0.2 + timeFrac * 0.8);
    lineColors.push(c.r, c.g, c.b);
  }
  geo.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));

  const mat = new THREE.LineBasicMaterial({
    vertexColors: true,
    transparent: true,
    opacity: 0.7,
    linewidth: 1,
  });

  return new THREE.Line(geo, mat);
}

// Build ribbon surfaces (filled quads between adjacent episodes for a topic)
function buildRibbonSurface(topicIdx) {
  if (!topicVisible[topicIdx]) return null;

  const maxEp = scrubberValue + 1;
  if (maxEp < 2) return null;

  const nextTopicIdx = (topicIdx + 1) % NUM_TOPICS;
  const tc = new THREE.Color(TOPIC_COLORS[topicIdx]);
  const dimTc = new THREE.Color(0x0a0a0f);

  const vertices = [];
  const colors = [];
  const indices = [];

  for (let ep = 0; ep < maxEp; ep++) {
    const z = -ep * Z_SPACING;
    const val = EPISODES[ep].coverage[topicIdx];
    const pt = radarPoint(topicIdx, val, z);
    const timeFrac = ep / (NUM_EPISODES - 1);
    const c = dimTc.clone().lerp(tc, 0.1 + timeFrac * 0.5);

    vertices.push(pt.x, pt.y, pt.z);
    colors.push(c.r, c.g, c.b);
  }

  // Connect adjacent episode points into a line strip along the outer edge
  // Then build a thin ribbon by also adding center-offset points
  // Actually — let's make a proper surface ribbon along each axis
  const vertices2 = [];
  const colors2 = [];
  const indices2 = [];

  for (let ep = 0; ep < maxEp; ep++) {
    const z = -ep * Z_SPACING;
    const val = EPISODES[ep].coverage[topicIdx];
    const timeFrac = ep / (NUM_EPISODES - 1);
    const c = dimTc.clone().lerp(tc, 0.08 + timeFrac * 0.35);

    const pt = radarPoint(topicIdx, val, z);
    // Inner point (slightly toward center)
    const innerR = Math.max(0, val - 0.08) * RADIUS_SCALE;
    const angle = topicAngle(topicIdx);
    const inner = new THREE.Vector3(
      Math.cos(angle) * innerR,
      Math.sin(angle) * innerR,
      z
    );

    vertices2.push(inner.x, inner.y, inner.z); // even index
    vertices2.push(pt.x, pt.y, pt.z);          // odd index
    colors2.push(c.r, c.g, c.b);
    colors2.push(c.r, c.g, c.b);
  }

  for (let ep = 0; ep < maxEp - 1; ep++) {
    const i = ep * 2;
    indices2.push(i, i + 1, i + 2);
    indices2.push(i + 1, i + 3, i + 2);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices2, 3));
  geo.setAttribute('color', new THREE.Float32BufferAttribute(colors2, 3));
  geo.setIndex(indices2);
  geo.computeVertexNormals();

  const mat = new THREE.MeshBasicMaterial({
    vertexColors: true,
    transparent: true,
    opacity: 0.4,
    side: THREE.DoubleSide,
    depthWrite: false,
  });

  return new THREE.Mesh(geo, mat);
}

// ── REBUILD SCENE ─────────────────────────────────────────────────────────────

function rebuildScene() {
  // Clear
  while (sliceGroup.children.length) sliceGroup.remove(sliceGroup.children[0]);
  while (ribbonGroup.children.length) ribbonGroup.remove(ribbonGroup.children[0]);
  sliceMeshes.length = 0;
  ribbonMeshes.length = 0;

  const maxEp = scrubberValue + 1;

  if (viewMode === 'latest') {
    // Only show the latest slice
    const idx = scrubberValue;
    const slice = buildSlice(idx);
    // Override z to 0 for flat view
    slice.position.z = idx * Z_SPACING;
    sliceGroup.add(slice);
    sliceMeshes.push(slice);

    const outline = buildSliceOutline(idx);
    outline.position.z = idx * Z_SPACING;
    sliceGroup.add(outline);
  } else {
    // Cumulative: show all slices up to scrubber
    for (let ep = 0; ep < maxEp; ep++) {
      const slice = buildSlice(ep);
      sliceGroup.add(slice);
      sliceMeshes.push(slice);

      const outline = buildSliceOutline(ep);
      sliceGroup.add(outline);
    }

    // Ribbons per topic
    for (let t = 0; t < NUM_TOPICS; t++) {
      const ribbon = buildRibbon(t);
      if (ribbon) {
        ribbonGroup.add(ribbon);
        ribbonMeshes.push(ribbon);
      }
      const surface = buildRibbonSurface(t);
      if (surface) {
        ribbonGroup.add(surface);
      }
    }
  }

  updateSidebarPcts();
}

// ── RAYCASTING / TOOLTIP ──────────────────────────────────────────────────────

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const tooltip = document.getElementById('tooltip');

function onMouseMove(e) {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(sliceMeshes, false);

  if (intersects.length > 0) {
    const hit = intersects[0];
    const mesh = hit.object;
    const epIdx = mesh.userData.episodeIdx;
    const ep = EPISODES[epIdx];

    // Determine which topic by angle of hit point relative to center
    const point = hit.point;
    const angle = Math.atan2(point.y, point.x);
    let normalizedAngle = angle + Math.PI / 2;
    if (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
    const topicIdx = Math.floor((normalizedAngle / (Math.PI * 2)) * NUM_TOPICS) % NUM_TOPICS;

    const topic = TOPICS[topicIdx];
    const cov = ep.coverage[topicIdx];
    const covPct = Math.round(cov * 100);
    const mins = (cov * topic.alloc).toFixed(1);

    tooltip.innerHTML = `
      <div class="tt-topic">${topic.name}</div>
      <div>Episode ${ep.episode} <span class="tt-dim">· ${ep.date}</span></div>
      <div>${covPct}% coverage <span class="tt-dim">· ~${mins}/${topic.alloc} min</span></div>
    `;
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX + 14) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
}

renderer.domElement.addEventListener('mousemove', onMouseMove);

// ── UI CONTROLS ───────────────────────────────────────────────────────────────

function setView(mode) {
  viewMode = mode;
  document.querySelectorAll('.toggle-btn').forEach(btn => {
    btn.classList.toggle('active', btn.textContent.toLowerCase() === mode);
  });
  rebuildScene();
}

function onScrub(val) {
  scrubberValue = parseInt(val);
  document.getElementById('episode-label').textContent = `Ep ${scrubberValue + 1}`;
  rebuildScene();
}

function togglePlay() {
  isPlaying = !isPlaying;
  document.getElementById('play-btn').innerHTML = isPlaying ? '&#9646;&#9646;' : '&#9654;';

  if (isPlaying) {
    scrubberValue = 0;
    document.getElementById('scrubber').value = 0;
    onScrub(0);

    playInterval = setInterval(() => {
      scrubberValue++;
      if (scrubberValue >= NUM_EPISODES) {
        scrubberValue = NUM_EPISODES - 1;
        isPlaying = false;
        document.getElementById('play-btn').innerHTML = '&#9654;';
        clearInterval(playInterval);
        return;
      }
      document.getElementById('scrubber').value = scrubberValue;
      onScrub(scrubberValue);
    }, 350);
  } else {
    clearInterval(playInterval);
  }
}

// Sidebar topic toggles
function buildSidebar() {
  const sidebar = document.getElementById('sidebar');
  sidebar.innerHTML = '';
  for (let t = 0; t < NUM_TOPICS; t++) {
    const div = document.createElement('div');
    div.className = 'topic-toggle' + (topicVisible[t] ? '' : ' off');
    div.innerHTML = `
      <span class="dot" style="background: #${TOPIC_COLORS[t].toString(16).padStart(6, '0')}"></span>
      <span class="label">${TOPICS[t].name}</span>
      <span class="pct" id="pct-${t}">—</span>
    `;
    div.onclick = () => {
      topicVisible[t] = !topicVisible[t];
      div.classList.toggle('off', !topicVisible[t]);
      rebuildScene();
    };
    sidebar.appendChild(div);
  }
}

function updateSidebarPcts() {
  const ep = EPISODES[scrubberValue];
  for (let t = 0; t < NUM_TOPICS; t++) {
    const el = document.getElementById(`pct-${t}`);
    if (el) {
      const pct = Math.round(ep.coverage[t] * 100);
      el.textContent = pct + '%';
    }
  }
}

buildSidebar();

// ── RESIZE ────────────────────────────────────────────────────────────────────

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ── ANIMATE ───────────────────────────────────────────────────────────────────

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

// ── INIT ──────────────────────────────────────────────────────────────────────

async function init() {
  await loadRealData();
  buildSidebar();
  buildAxes();
  rebuildScene();
  animate();
}

init();
</script>
</body>
</html>
